{"version":3,"sources":["js/dispatcher.js","js/actions.js","js/stores/base.js","js/stores/settingstore.js","js/stores/eventlogstore.js","js/connection.js","js/components/header.js","js/components/traffictable.js","js/components/eventlog.js","js/components/footer.js","js/components/proxyapp.js","js/app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA","file":"app.js","sourcesContent":["const PayloadSources = {\n    VIEW_ACTION: \"VIEW_ACTION\",\n    SERVER_ACTION: \"SERVER_ACTION\"\n};\n\n\nfunction Dispatcher() {\n    this.callbacks = [];\n}\nDispatcher.prototype.register = function (callback) {\n    this.callbacks.push(callback);\n};\nDispatcher.prototype.unregister = function (callback) {\n    var index = this.callbacks.indexOf(f);\n    if (index >= 0) {\n        this.callbacks.splice(this.callbacks.indexOf(f), 1);\n    }\n};\nDispatcher.prototype.dispatch = function (payload) {\n    console.debug(\"dispatch\", payload);\n    this.callbacks.forEach(function (callback) {\n        callback(payload);\n    });\n};\n\n\nAppDispatcher = new Dispatcher();\nAppDispatcher.dispatchViewAction = function (action) {\n    action.actionSource = PayloadSources.VIEW_ACTION;\n    this.dispatch(action);\n};\nAppDispatcher.dispatchServerAction = function (action) {\n    action.actionSource = PayloadSources.SERVER_ACTION;\n    this.dispatch(action);\n};\n","var ActionTypes = {\n    SETTINGS_UPDATE: \"SETTINGS_UPDATE\",\n    EVENTLOG_ADD: \"EVENTLOG_ADD\"\n};\n\nvar SettingsActions = {\n    update: function (settings) {\n        settings = _.merge({}, SettingsStore.getAll(), settings);\n        //TODO: Update server.\n\n        //Facebook Flux: We do an optimistic update on the client already.\n        AppDispatcher.dispatchViewAction({\n            actionType: ActionTypes.SETTINGS_UPDATE,\n            settings: settings\n        });\n    }\n};\n","function EventEmitter() {\n    this.listeners = {};\n}\nEventEmitter.prototype.emit = function (event) {\n    if (!(event in this.listeners)) {\n        return;\n    }\n    this.listeners[event].forEach(function (listener) {\n        listener.apply(this, arguments);\n    }.bind(this));\n};\nEventEmitter.prototype.addListener = function (event, f) {\n    this.listeners[event] = this.listeners[event] || [];\n    this.listeners[event].push(f);\n};\nEventEmitter.prototype.removeListener = function (event, f) {\n    if (!(event in this.listeners)) {\n        return false;\n    }\n    var index = this.listeners[event].indexOf(f);\n    if (index >= 0) {\n        this.listeners[event].splice(index, 1);\n    }\n};\n","function _SettingsStore() {\n    EventEmitter.call(this);\n\n    //FIXME: What do we do if we haven't requested anything from the server yet?\n    this.settings = {\n        version: \"0.12\",\n        showEventLog: true,\n        mode: \"transparent\",\n    };\n}\n_.extend(_SettingsStore.prototype, EventEmitter.prototype, {\n    getAll: function () {\n        return this.settings;\n    },\n    handle: function (action) {\n        switch (action.actionType) {\n            case ActionTypes.SETTINGS_UPDATE:\n                this.settings = action.settings;\n                this.emit(\"change\");\n                break;\n            default:\n                return;\n        }\n    }\n});\n\nvar SettingsStore = new _SettingsStore();\nAppDispatcher.register(SettingsStore.handle.bind(SettingsStore));\n","//\n// We have an EventLogView and an EventLogStore:\n// The basic architecture is that one can request views on the event log\n// from the store, which returns a view object and then deals with getting the data required for the view.\n// The view object is accessed by React components and distributes updates etc.\n//\n// See also: components/EventLog.react.js\nfunction EventLogView(store, live) {\n    EventEmitter.call(this);\n    this.$EventLogView_store = store;\n    this.live = live;\n    this.log = [];\n\n    this.add = this.add.bind(this);\n\n    if (live) {\n        this.$EventLogView_store.addListener(\"new_entry\", this.add);\n    }\n}\n_.extend(EventLogView.prototype, EventEmitter.prototype, {\n    close: function () {\n        this.$EventLogView_store.removeListener(\"new_entry\", this.add);\n    },\n    getAll: function () {\n        return this.log;\n    },\n    add: function (entry) {\n        this.log.push(entry);\n        this.emit(\"change\");\n    },\n    add_bulk: function (messages) {\n        var log = messages;\n        var last_id = log[log.length - 1].id;\n        var to_add = _.filter(this.log, function (entry) {\n            return entry.id > last_id;\n        });\n        this.log = log.concat(to_add);\n        this.emit(\"change\");\n    }\n});\n\n\nfunction _EventLogStore() {\n    EventEmitter.call(this);\n}\n_.extend(_EventLogStore.prototype, EventEmitter.prototype, {\n    getView: function (since) {\n        var view = new EventLogView(this, !since);\n\n        //TODO: Really do bulk retrieval of last messages.\n        window.setTimeout(function () {\n            view.add_bulk([\n                {\n                    id: 1,\n                    message: \"Hello World\"\n                },\n                {\n                    id: 2,\n                    message: \"I was already transmitted as an event.\"\n                }\n            ]);\n        }, 100);\n\n        var id = 2;\n        view.add({\n            id: id++,\n            message: \"I was already transmitted as an event.\"\n        });\n        view.add({\n            id: id++,\n            message: \"I was only transmitted as an event before the bulk was added..\"\n        });\n        window.setInterval(function () {\n            view.add({\n                id: id++,\n                message: \".\"\n            });\n        }, 1000);\n        return view;\n    },\n    handle: function (action) {\n        switch (action.actionType) {\n            case ActionTypes.EVENTLOG_ADD:\n                this.emit(\"new_message\", action.message);\n                break;\n            default:\n                return;\n        }\n    }\n});\n\n\nvar EventLogStore = new _EventLogStore();\nAppDispatcher.register(EventLogStore.handle.bind(EventLogStore));\n","function _Connection(url) {\n    this.url = url;\n}\n_Connection.prototype.init = function () {\n    this.openWebSocketConnection();\n};\n_Connection.prototype.openWebSocketConnection = function () {\n    this.ws = new WebSocket(this.url.replace(\"http\", \"ws\"));\n    var ws = this.ws;\n\n    ws.onopen = this.onopen.bind(this);\n    ws.onmessage = this.onmessage.bind(this);\n    ws.onerror = this.onerror.bind(this);\n    ws.onclose = this.onclose.bind(this);\n};\n_Connection.prototype.onopen = function (open) {\n    console.log(\"onopen\", this, arguments);\n};\n_Connection.prototype.onmessage = function (message) {\n    //AppDispatcher.dispatchServerAction(...);\n    var m = JSON.parse(message.data);\n    switch (m.type){\n        case \"flow\":\n            console.log(\"flow\", m.data);\n            break;\n        case \"event\":\n            console.log(\"event\", m.data.message)\n            break;\n    }\n};\n_Connection.prototype.onerror = function (error) {\n    console.log(\"onerror\", this, arguments);\n};\n_Connection.prototype.onclose = function (close) {\n    console.log(\"onclose\", this, arguments);\n};\n\nvar Connection = new _Connection(location.origin + \"/updates\");\n","/** @jsx React.DOM */\n\nvar MainMenu = React.createClass({\n    toggleEventLog: function () {\n        SettingsActions.update({\n            showEventLog: !this.props.settings.showEventLog\n        });\n    },\n    render: function () {\n        return (\n            <div>\n                <button className={\"btn \" + (this.props.settings.showEventLog ? \"btn-primary\" : \"btn-default\")} onClick={this.toggleEventLog}>\n                <i className=\"fa fa-database\"></i> Display Event Log\n                </button>\n            </div>\n            );\n    }\n});\nvar ToolsMenu = React.createClass({\n    render: function () {\n        return <div>Tools Menu</div>;\n    }\n});\nvar ReportsMenu = React.createClass({\n    render: function () {\n        return <div>Reports Menu</div>;\n    }\n});\n\n\nvar _Header_Entries = {\n    main: {\n        title: \"Traffic\",\n        route: \"main\",\n        menu: MainMenu\n    },\n    tools: {\n        title: \"Tools\",\n        route: \"main\",\n        menu: ToolsMenu\n    },\n    reports: {\n        title: \"Visualization\",\n        route: \"reports\",\n        menu: ReportsMenu\n    }\n};\n\nvar Header = React.createClass({\n    getInitialState: function () {\n        return {\n            active: \"main\"\n        };\n    },\n    handleClick: function (active) {\n        this.setState({active: active});\n        ReactRouter.transitionTo(_Header_Entries[active].route);\n        return false;\n    },\n    handleFileClick: function () {\n        console.log(\"File click\");\n    },\n    render: function () {\n        var header = [];\n        for (var item in _Header_Entries) {\n            var classes = this.state.active == item ? \"active\" : \"\";\n            header.push(<a key={item} href=\"#\" className={classes}\n                onClick={this.handleClick.bind(this, item)}>{ _Header_Entries[item].title }</a>);\n        }\n\n        var menu = _Header_Entries[this.state.active].menu({\n            settings: this.props.settings\n        });\n        return (\n            <header>\n                <div className=\"title-bar\">\n                    mitmproxy { this.props.settings.version }\n                </div>\n                <nav>\n                    <a href=\"#\" className=\"special\" onClick={this.handleFileClick}> File </a>\n                    {header}\n                </nav>\n                <div className=\"menu\">\n                    { menu }\n                </div>\n            </header>\n            );\n    }\n});\n","/** @jsx React.DOM */\n\nvar TrafficTable = React.createClass({\n    getInitialState: function () {\n        return {\n            flows: []\n        };\n    },\n    componentDidMount: function () {\n        //this.flowStore = FlowStore.getView();\n        //this.flowStore.addListener(\"change\",this.onFlowChange);\n    },\n    componentWillUnmount: function () {\n        //this.flowStore.removeListener(\"change\",this.onFlowChange);\n        //this.flowStore.close();\n    },\n    onFlowChange: function () {\n        this.setState({\n            //flows: this.flowStore.getAll()\n        });\n    },\n    render: function () {\n        /*var flows = this.state.flows.map(function(flow){\n         return <div>{flow.request.method} {flow.request.scheme}://{flow.request.host}{flow.request.path}</div>;\n         }); */\n        //Dummy Text for layout testing\n        x = \"Flow\";\n        i = 12;\n        while (i--) x += x;\n        return (\n            <div>Flow</div> \n            );\n    }\n});\n","/** @jsx React.DOM */\n\nvar EventLog = React.createClass({\n    getInitialState: function () {\n        return {\n            log: []\n        };\n    },\n    componentDidMount: function () {\n        this.log = EventLogStore.getView();\n        this.log.addListener(\"change\", this.onEventLogChange);\n    },\n    componentWillUnmount: function () {\n        this.log.removeListener(\"change\", this.onEventLogChange);\n        this.log.close();\n    },\n    onEventLogChange: function () {\n        this.setState({\n            log: this.log.getAll()\n        });\n    },\n    close: function () {\n        SettingsActions.update({\n            showEventLog: false\n        });\n    },\n    render: function () {\n        //var messages = this.state.log.map(row => (<div key={row.id}>{row.message}</div>));\n        var messages = [];\n        return (\n            <div className=\"eventlog\">\n                <pre>\n                    <i className=\"fa fa-close close-button\" onClick={this.close}></i>\n                    {messages}\n                </pre>\n            </div>\n            );\n    }\n});\n","/** @jsx React.DOM */\n\nvar Footer = React.createClass({\n    render: function () {\n        var mode = this.props.settings.mode;\n        return (\n            <footer>\n                {mode != \"regular\" ? <span className=\"label label-success\">{mode} mode</span> : null}\n            </footer>\n            );\n    }\n});\n","/** @jsx React.DOM */\n\n//TODO: Move out of here, just a stub.\nvar Reports = React.createClass({\n    render: function () {\n        return <div>ReportEditor</div>;\n    }\n});\n\n\nvar ProxyAppMain = React.createClass({\n    getInitialState: function () {\n        return { settings: SettingsStore.getAll() };\n    },\n    componentDidMount: function () {\n        SettingsStore.addListener(\"change\", this.onSettingsChange);\n    },\n    componentWillUnmount: function () {\n        SettingsStore.removeListener(\"change\", this.onSettingsChange);\n    },\n    onSettingsChange: function () {\n        console.log(\"onSettingsChange\");\n        this.setState({settings: SettingsStore.getAll()});\n    },\n    render: function () {\n        return (\n            <div id=\"container\">\n                <Header settings={this.state.settings}/>\n                <div id=\"main\"><this.props.activeRouteHandler/></div>\n                    {this.state.settings.showEventLog ? <EventLog/> : null}\n                <Footer settings={this.state.settings}/>\n            </div>\n            );\n    }\n});\n\n\nvar ProxyApp = (\n    <ReactRouter.Routes location=\"hash\">\n        <ReactRouter.Route name=\"app\" path=\"/\" handler={ProxyAppMain}>\n            <ReactRouter.Route name=\"main\" handler={TrafficTable}/>\n            <ReactRouter.Route name=\"reports\" handler={Reports}/>\n            <ReactRouter.Redirect to=\"main\"/>\n        </ReactRouter.Route>\n    </ReactRouter.Routes>\n    );\n","$(function () {\n    Connection.init();\n    app = React.renderComponent(ProxyApp, document.body);\n});"],"sourceRoot":"/static"}